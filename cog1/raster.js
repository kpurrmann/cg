/**
 * Rasterization algorithms.
 *
 * @namespace cog1
 * @module raster
 */
define(["exports", "dojo", "shader", "framebuffer", "data", "glMatrix"], function(exports, dojo, shader, framebuffer, data) {

    // Drawing context for canvas.
    // As raster uses the framebuffer to access the canvas,
    // ctx is merely for debug.
    var ctx;

    // Plane equation of polygon.
    var A = 1;
    var B = 1;
    var C = 1;
    var D = 1;
    var AdivC;
    // Pre-calculate for speed-up.

    // For each polygon we store all points from all edges
    // generated by the Bresenham algorithm.
    // They are use for the scan-line fill algorithm.
    // After processing a polygon the data structures are reset.
    // One ArrayList for every scan-line.
    var scanlineIntersection = [];

    function init(_ctx, _bgColor) {
        ctx = _ctx;
        framebuffer.init(ctx, _bgColor);
    }

    /*
	 * Convienence function when start and end points are given as 3D-vectors.
	 */
    function drawLineBresenhamGivenStartEndPoint(ctx, startPoint, endPoint, color, storeIntersectionForScanlineFill) {

        // Convert parameters to integer values.
        var startX = Math.floor(startPoint[0]);
        var startY = Math.floor(startPoint[1]);
        var endX = Math.floor(endPoint[0]);
        var endY = Math.floor(endPoint[1]);

        drawLineBresenham(ctx, startX, startY, endX, endY, color, storeIntersectionForScanlineFill);
    }

    /*
	 * Draw lines with bresenham algorithm.
	 * Also store intersections of the current edge for scanline.
	 * @ Start and end points should be integer values.
	 * @ parameter storeIntersectionForScanlineFill: if false edges are only calculated
	 * @ to be filled with scanline but not drawn.
	 */
    function drawLineBresenham(ctx, startX, startY, endX, endY, color, storeIntersectionForScanlineFill) {

        var x = startX;
        var y = startY;

        // Abstand
        var dX = endX - startX;
        var dY = endY - startY;

        // BetrÃ¤ge
        var dXAbs = Math.abs(dX);
        var dYAbs = Math.abs(dY);

        // Start kleiner als Ende
        var dXSign = (dX > 0) ? 1 : -1;
        var dYSign = (dY > 0) ? 1 : -1;

        // shortcuts for speedup.
        var dXAbs2 = 2 * dXAbs;
        var dYAbs2 = 2 * dYAbs;
        var dXdYdiff2 = 2 * (dXAbs - dYAbs);
        var dYdXdiff2 = 2 * (dYAbs - dXAbs);
        var err;

        if(dXAbs >= dYAbs){
            err = dXAbs - dYAbs2;
            while (x != endX){
                x += dXSign;
                if (err > 0){
                    err -= dYAbs2;
                } else {
                    y += dYSign;
                    err += dXdYdiff2;
                    addIntersection(x, y);
                }
                framebuffer.set(x, y, getZ(x,y), color);
            }
        } else {
            err = dYAbs - dXAbs2;
            while (y != endY){
                y += dYSign;
                if(err > 0){
                    err -= dXAbs2;
                } else {
                    x += dXSign;
                    err += dYdXdiff2;
                }
                framebuffer.set(x, y, getZ(x,y), color);
                addIntersection(x, y);
            }
        }
    }

    /*
	 * Fill a polygone into the frambuffer
	 * @parametes fill or stroke outline
	 * @parametes ctx is given for debug
	 */
    function scanlineDrawPolygon(ctx, vertices, polygon, color, fill) {
        var derivative, lastDerivative = 0;
        
        // To fill the polygon, we want at least a triangle to proceed.
        if(fill && polygon.length < 3) {
            return;
        }

        if(fill) {
            clearIntersections();
        }

        // Calculate the plane in which the polygon lies
        // to determine z-values of intermediate points.
        calcPlaneEquation(vertices, polygon);

        // Loop over vertices/edges in polygon.
        for(var v = 0; v < polygon.length; v++) {
            // Convert parameters to integer values.
            var startPoint = vertices[polygon[v]];
            // Connect edge to next or to first vertex to close the polygon.
            var nextIndex = (v < polygon.length - 1) ? v + 1 : 0;
            var endPoint = vertices[polygon[nextIndex]];
            var currX = Math.floor(startPoint[0]);
            var currY = Math.floor(startPoint[1]);
            var nextX = Math.floor(endPoint[0]);
            var nextY = Math.floor(endPoint[1]);
            var fillArray = [];
           

            drawLineBresenham(ctx, currX, currY, nextX, nextY, color, fill);

            if(!fill) {
                continue;
            }

            lastDerivative = derivative;
            derivative = calcDerivative(currY, nextY);

            if (derivative == 0) {
                derivative = lastDerivative;
            }

        }
        if(!fill) {
            return;
        }

        for(var y = 0; y < ctx.height; y++) {
            
            if(!scanlineIntersection[y] ) {
                continue;
            }

            scanlineIntersection[y].sort(function(a,b){
                return a-b;
            });

            //            console.log(y + " :"  + scanlineIntersection[y]);

            for(var j = 0; j < scanlineIntersection[y].length; j++) {
                drawLineBresenham(ctx, scanlineIntersection[y][j], y, scanlineIntersection[y][j+1], y, color, false);
            }
        }

    }
	

    /*
     * Calculate the derivative (only the sign) of a polygon edge.
     * @ return +-1 or 0.
     */
    function calcDerivative(currY, nextY) {
        // y axis from top to bottom.
        if(currY < nextY) {
            return -1;
        } else if(currY > nextY) {
            return +1;
        } else {
            return 0;
        }
    }

    /*
     * Used for drawing lines with correct z-buffering.
     * Invent a second direction n perpendicular to direction
     * and create a fake plane.
     */
    function calcPlaneEquationForStraightLine(point, direction) {
        var d = direction;
        var n = vec3.create();
        // Calculate n via a second direction.
        //var d1 = vec3.create();
        //vec3.set([d[2],d[1],d[0]],d1);
        //vec3.cross(d, d1, n);
        // Set directly some n perpendicular to d.
        vec3.set([d[1], -d[0], -d[2]], n);
        vec3.normalize(n);
        A = n[0];
        B = n[1];
        C = n[2];
        D = -vec3.dot(n, point);
        AdivC = 0;
    }

    function calcPlaneEquation(vertices, polygon) {

        // Normal vector and its length.
        var n = vec3.create();
        var nLength = data.calculateNormalForPolygon(vertices, polygon, n);


        if(nLength == 0) {
            return;
        }

        // BEGIN exercise z-Buffer:

        // Assign parameters for plane equation.

        // Project first vertex (could be any) on normal.
        // The result is the distance D of polygon plane to origin.

        A = n[0];
        B = n[1];
        C = n[2];
        D = -vec3.dot(n, vertices[polygon[0]]);
        AdivC = A / C;
        

    // END exercise z-Buffer
    }

    /*
     * Call for new frame.
     */
    function clearIntersections() {
        scanlineIntersection = [];
    }

    /*
     * Add (edge-)points from bresenham to scanlines.
     */
    function addIntersection(x, y) {

        // Do some hacked clipping.
        // point out of y-range are on no scanline and can be ignored.
        if(y < 0 || y >= ctx.height) {
            return;
        }
        // Slide point to the left or right of the canvas back onto the edge,
        // but not on the canvas. They are cut off by the framebuffer if this
        // leads to a mere artifact (vertical lines at the left or right edge).
        if(x < 0) {
            x = -1;
        }
        if(x >= ctx.width) {
            x = ctx.width;
        }

        // Check if this is the first point in this scanline.
        if(!dojo.isArray(scanlineIntersection[y])) {
            scanlineIntersection[y] = [];
        }
        scanlineIntersection[y].push(x);
    }

    /*
     * Calculate the z-value for any point on
     * the polygon currently processed.
     */
    function getZ(x, y) {
        // We assume that the plane equation is up-to-date
        // with the current polygon.
        return -(A * x + B * y + D) / C;
    }

    /*
     * For Debug
     */
    function drawLine(ctx, startX, startY, endX, endY, color) {
        var colorname = Object.keys(color)[0];
        ctx.fillStyle = colorname;
        ctx.strokeStyle = colorname;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        //ctx.closePath();
        ctx.stroke();
    }

    // Public API.
    exports.init = init;
    exports.drawLineBresenham = drawLineBresenham;
    exports.drawLineBresenhamGivenStartEndPoint = drawLineBresenhamGivenStartEndPoint;
    exports.calcPlaneEquationForStraightLine = calcPlaneEquationForStraightLine;
    exports.scanlineDrawPolygon = scanlineDrawPolygon;
    exports.clearIntersections = clearIntersections;
});
