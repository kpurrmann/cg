/**
 * Rasterization algorithms.
 *
 * @namespace cog1
 * @module raster
 */
define(["exports", "dojo", "framebuffer", "glMatrix"], function(exports, dojo, framebuffer) {

	// Drawing context for canvas.
	// As raster uses the framebuffer to access the canvas,
	// ctx is merely for debug.
	var ctx;

	// Plane equation of polygon.
	var A = 1;
	var B = 1;
	var C = 1;
	var D = 1;
	var AdivC;
	// Pre-calculate for speed-up.

	// For each polygon we store all points from all edges
	// generated by the Bresenham algorithm.
	// They are use for the scan-line fill algorithm.
	// After processing a polygon the data structures are reset.
	// One ArrayList for every scan-line.
	var scanlineIntersection = [];

	function init(_ctx) {
		ctx = _ctx;
		framebuffer.init(ctx);
	}

	/*
	 * Draw lines with bresenham algorithm.
	 * Also store intersections of the current edge for scanline.
	 * @ Start and end points should be integer values.
	 * @ parameter storeIntersectionForScanlineFill: if false edges are only calculated
	 * @ to be filled with scanline but not drawn.
	 */
	function drawLineBresenham(ctx, startX, startY, endX, endY, color, storeIntersectionForScanlineFill) {

                // Startvariablen
		var x = startX;
		var y = startY;
                
                // Abstand
		var dX = endX - startX;
		var dY = endY - startY;
                
                // BetrÃ¤ge 
		var dXAbs = Math.abs(dX);
		var dYAbs = Math.abs(dY);
		
                // Start kleiner als Ende
                var dXSign = (dX > 0) ? 1 : -1;
		var dYSign = (dY > 0) ? 1 : -1;

		// shortcuts for speedup.
		var dXAbs2 = 2 * dXAbs;
		var dYAbs2 = 2 * dYAbs;
		var dXdYdiff2 = 2 * (dXAbs - dYAbs);
		var dYdXdiff2 = 2 * (dYAbs - dXAbs);
		var err;

		if(dXAbs >= dYAbs){
			err = dXAbs - dYAbs2;
			while (x != endX){
				x += dXSign;
				if (err > 0){
					err -= dYAbs2;
				} else {
					y += dYSign;
					err += dXdYdiff2;
				}
//				ctx.fillStyle = Object.keys(color)[0];
//				ctx.fillRect(x,y,1,1);
				framebuffer.set(x, y, 0, color);
				addIntersection(x, y);
			}
		} else {
			err = dYAbs - dXAbs2;
			while (y != endY){
				y += dYSign;
				if(err > 0){
					err -= dXAbs2;
				} else {
					x += dXSign;
					err += dYdXdiff2;
				}
//				ctx.fillStyle = Object.keys(color)[0];
//				ctx.fillRect(x,y,1,1);
				framebuffer.set(x, y, 0, color);
				addIntersection(x, y);
			}
		}
	}

	/*
	 * Fill a polygone into the frambuffer
	 * @parametes fill or stroke outline
	 * @parametes ctx is given for debug
	 */
	function scanlineDrawPolygon(ctx, vertices, polygon, color, fill) {

		// We want at least a triangle to proceed.
		if(polygon.length < 3) {
			return;
		}

		if(fill) {
			clearIntersections();
		}

		// Calculate the plane in which the polygon lies
		// to determine z-values of intermediate points.
		calcPlaneEquation(vertices, polygon);

		// Loop over vertices/edges in polygon.
		for(var v = 0; v < polygon.length - 1; v++) {
			// Convert parameters to integer values.
			var currX = Math.floor(vertices[polygon[v]][0]);
			var currY = Math.floor(vertices[polygon[v]][1]);
			var nextX = Math.floor(vertices[polygon[v+1]][0]);
			var nextY = Math.floor(vertices[polygon[v+1]][1]);

			drawLineBresenham(ctx, currX, currY, nextX, nextY, color, fill);

			if(!fill) {
				continue;
			}
			
//			console.log('v: ' + v);
//			console.log('ctx.height: ' + ctx.height);
//			console.log('vertices: ' + vertices.length);
//			console.log('currX: ' + currX);
//			console.log('currY: ' + currY);
//			console.log('nextX: ' + nextX);
//			console.log('scanlineIntersection: ' + scanlineIntersection);
			// ToDo exercise...
			// Complete the scanline function (around the comments).
			// ........

			// Calculate current and save last derivative.
			if(!calcDerivative(currY, nextY)){
				currY = nextY;

			}
			if(!calcDerivative(currX, nextX)) {
				currX = nextX;
			}

                        
			// If current derivative ==0 then keep the last one
			// that was not 0 as last.
			//
			//
			// Add start point if edges are non monotonous.



			// Add end point of non horizontal edges.
                           
		}

		if(!fill) {
			return;
		}

		// Fill polygon line by line using the scan-line algorithm.
		// Loop over scan lines.

		for(var y=0; y < ctx.height; y++){
			var line = scanlineIntersection[y];
			if(!line){
				continue;
			}

			line.sort(function(a,b){
				return a - b;
			});

			drawLineBresenham(ctx, line[0], y, line[line.length-1], y, color, fill);
		}
		clearIntersections();
	}

	/*
	 * Calculate the derivative (only the sign) of a polygon edge.
	 * @ return +-1 or 0.
	 */
	function calcDerivative(currY, nextY) {
		// y axis from top to bottom.
		if(currY < nextY) {
			return -1;
		} else if(currY > nextY) {
			return +1;
		} else {
			return 0;
		}
	}

	function calcPlaneEquation(vertices, polygon) {
		// Two edge-vectors dim 3:
		var e = [vec3.create(), vec3.create()];
		// Normal vector and its length.
		var n = vec3.create();
		var nLength = 0;

//		console.log(vertices);
		console.log(polygon);

		// We assume that all vertices of the polygon are in one plane.
		for
		// Calculate two (non parallel) vectors inside the plane of the polygon.
		// We assume that at least two (consecutive) vertices of a polygon
		// are not on a straight line with the first vertex.
		
		
		//ToDo exercise ......
	}

	/*
	 * Call for new frame.
	 */
	function clearIntersections() {
		scanlineIntersection = [];
	}

	/*
	 * Add (edge-)points from bresenham to scanlines.
	 */
	function addIntersection(x, y) {

		// Do some hacked clipping.
		if(x < 0) {
			x = 0;
		}
		if(y < 0) {
			y = 0;
		}
		if(x >= ctx.width) {
			x = ctx.width - 1;
		}
		if(y >= ctx.height) {
			y = ctx.height - 1;
		}

		if(x >= 0 && x < ctx.width && y >= 0 && y < ctx.height) {
			// Check if this is the first point in this scanline.
			if(!dojo.isArray(scanlineIntersection[y])) {
				scanlineIntersection[y] = [];
			}
			scanlineIntersection[y].push(x);
//			console.log ("y: " + y + " " + scanlineIntersection[y].push(x) + " x: "+ x + " " + scanlineIntersection[y]) ;
		} else {
			console.log("Error in addIntersection (out of screen):" + x + "," + y);
		}
	}

	/*
	 * Calculate the z-value for any point on
	 * the polygon currently processed.
	 */
	function getZ(x, y) {
		// We assume that the plane equation is up-to-date
		// with the current polygon.
		return -(A * x + B * y + D) / C;
	}

	/*
	 * For Debug
	 */
	function drawLine(ctx, startX, startY, endX, endY, color) {
		var colorname = Object.keys(color)[0];
		ctx.fillStyle = colorname;
		ctx.strokeStyle = colorname;
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		//ctx.closePath();
		ctx.stroke();
	}

	// Public API.
	exports.init = init;
	exports.drawLineBresenham = drawLineBresenham;
	exports.scanlineDrawPolygon = scanlineDrawPolygon;
	exports.clearIntersections = clearIntersections;
});
